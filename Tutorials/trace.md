## Trace generated by gem5

A short example instruction trace is included ([trace_example.sq.txt]() and
[trace_example.txt]()), where [trace_example.txt]() includes all instructions
and [trace_example.sq.txt]() includes all store instructions.
Each line is an instruction, and an instruction contains a bound of numbers.
To reason about these numbers, please see the function at
[https://github.com/lingda-li/gem5/blob/ml_sim/src/cpu/o3/dyn_inst.cc#L449](),
which prints out these numbers.
Use the 4th instruction in [trace_example.txt]() as an example,
```
0 -1 80500 120500 121000 1500 2500 3000 3000 47 0 0 0 0 0 0 0 0 0 0 0 0 0  1 549755747984 8 2 -1 -1 -1 0 0 0 0 0 0  4196460 0 0 -1 -1 -1 -1 0 0 0 0 0  1 1  0 42  0 1
```

These numbers are:

**0**: whether this instruction incurs a fault during execution.

**-1**: logical store queue index for store instructions, -1 for other instructions.

80500: when this instruction is fetched. All latencies here and below are in the unit of ps.

120500: how long it takes to get out of reorder buffer.

121000: how long it takes to retire (retire latency).

1500: decode latency.

2500: rename latency.

3000: dispatch latency.

3000: issue latency.

**47**: op class defined by gem5.

**0**: whether it is a micro operation.

**0**: whether it is a conditional branch.

**0**: whether it is an unconditional branch.

**0**: whether it is a direct branch.

**0**: whether it needs to squash instructions after it.

**0**: whether instructions need to execute sequentially after it.

**0**: whether instructions need to execute sequentially before it.

**0**: whether it is an atomic instruction.

**0**: whether it is a conditional store instruction.

**0**: whether it acts a barrier for memory read.

**0**: whether it acts a barrier for memory write.

**0**: whether it is a quiesce instruction.

**0**: whether it is a non speculative instruction.

**1**: whether it accesses memory.

**549755747984**: memory address it accesses.

**8**: memory size it accesses.

2: how many cache/memory levels it goes through to satisfy the request.

-1 -1 -1: Data MMU walking depths in case of DTLB miss.

0 0 0: Data MMU walking addresses in case of DTLB miss.

0 0 0: the number of cache writebacks due to data access in case of cache replacement.

**4196460**: program counter.

**0**: whether it branches.

0: whether a branch is mis-predicted.

-1: how many cache/memory levels it goes through to fetch the instruction.

-1 -1 -1: Instruction MMU walking depths in case of ITLB miss.

0 0 0: Instruction MMU walking addresses in case of ITLB miss.

0 0: the number of cache writebacks due to instruction fetch in case of cache replacement.

**1 1**: the number of source and destination registers, which decides how many registers are listed behind them.

**0 42**: the category and index of the first and only source register.

**0 1**: the category and index of the first and only destination register.

**Bolded numbers** are required for inference/prediction, and others are only needed for training.
